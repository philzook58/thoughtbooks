(declare-sort Ob 0)
(declare-sort TYPE 0)
(declare-sort Hom 0)
(declare-fun id (Ob) Hom)
(declare-fun Hom (Ob Ob) TYPE)
(declare-fun compose (Ob Ob Ob Hom Hom) Hom)
(declare-fun otimes (Ob Ob) Ob)
(declare-fun Ob () TYPE)

(declare-fun otimes (Ob Ob Ob Ob Hom Hom) Hom)
(declare-fun munit () Ob)
(declare-fun braid (Ob Ob) Hom)
(declare-fun mcopy (Ob) Hom)
(declare-fun delete (Ob) Hom)
(declare-fun pair (Ob Ob Ob Hom Hom) Hom)
(declare-fun proj1 (Ob Ob) Hom)
(declare-fun proj2 (Ob Ob) Hom)
(declare-fun B () Ob)
(declare-fun A () Ob)

(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (f Hom) (g Hom) (h Hom))
  (! 
         (= (compose A C D (compose A B C f g) h) (compose A B D f (compose B C D g h)))
     :pattern ((compose A C D (compose A B C f g) h))
     :pattern ((compose A B D f (compose B C D g h))))))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (! (= (compose A B B f (id B)) f)
     :pattern ((compose A B B f (id B)) )

   )))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (! (= (compose A A B (id A) f) f)
     :pattern ((compose A A B (id A) f) (Hom A B))
   ;  :pattern (pattern f (Hom A B))
   )))
(assert (forall ((A Ob) (B Ob) (C Ob))
  (! (= (otimes (otimes A B) C) (otimes A (otimes B C)))
     :pattern ((otimes (otimes A B) C))
     :pattern ((otimes A (otimes B C))))))
(assert (forall ((A Ob))
  (! (= (otimes A munit) A) ;:pattern ((otimes A munit)) 
  ;:pattern (pattern A))
  )))
(assert (forall ((A Ob))
  (! (= (otimes munit A) A) ;:pattern ((otimes munit A)) ;:pattern (pattern A)
  )))
;(assert (forall ((A Ob) (B Ob) (C Ob) (X Ob) (Y Ob) (Z Ob) (f Hom) (g Hom) (h Hom))
;  (! (=> (and (= (typo f) (Hom A X))
;              (= (typo g) (Hom B Y))
;              (= (typo h) (Hom C Z)))
;         (= (otimes (otimes f g) h) (otimes f (otimes g h))))
;     :pattern ((otimes (otimes f g) h) (Hom A X) (Hom B Y) (Hom C Z))
;     :pattern ((otimes f (otimes g h)) (Hom A X) (Hom B Y) (Hom C Z)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (Y Ob) (Z Ob) (f Hom) (g Hom) (h Hom))
  (!       (= (otimes (otimes A C) Y (otimes B D) Z (otimes A C B D f g) h)
              (otimes A (otimes C Y) B (otimes D Z) f (otimes C Y D Z g h)))
     :pattern ((otimes (otimes A C) Y (otimes B D) Z (otimes A C B D f g) h) )
     :pattern ((otimes A (otimes C Y) B (otimes D Z) f (otimes C Y D Z g h))))))
(assert (forall ((A Ob)
         (B Ob)
         (C Ob)
         (X Ob)
         (Y Ob)
         (Z Ob)
         (f Hom)
         (h Hom)
         (g Hom)
         (k Hom))
  (!
         (= (compose (otimes A X) (otimes B Y) (otimes C Z) (otimes A X B Y f g) (otimes B Y C Z h k))
            (otimes A X B Y (compose A B C f h) (compose X Y Z g k)))
     :pattern ((compose (otimes A X) (otimes B Y) (otimes C Z) (otimes A X B Y f g) (otimes B Y C Z h k)))
     :pattern ((otimes A X B Y (compose A B C f h) (compose X Y Z g k))))))
               
(assert (forall ((A Ob) (B Ob))
  (! (= (id (otimes A B)) (otimes A B A B (id A) (id B)))
     :pattern ((id (otimes A B)))
     :pattern ((otimes A B A B (id A) (id B))))))
(assert (forall ((A Ob) (B Ob))
  (! (= (compose (otimes A B) (otimes B A) (otimes A B) (braid A B) (braid B A)) (id (otimes A B)))
     :pattern ((compose (otimes A B) (otimes B A) (otimes A B) (braid A B) (braid B A)))
     :pattern ((id (otimes A B))))))
(assert (forall ((A Ob) (B Ob) (C Ob))
  (! (= (braid A (otimes B C))
        (compose 
            (otimes (otimes A B) C) 
            (otimes (otimes B A) C)
            (otimes B (otimes C A))  
        (otimes (otimes A B) C (otimes B A) C (braid A B) (id C)) (otimes B (otimes A C) B (otimes C A) (id B) (braid A C))))
     :pattern ((braid A (otimes B C)))
     :pattern ((compose 
            (otimes (otimes A B) C) 
            (otimes (otimes B A) C)
            (otimes B (otimes C A))  
        (otimes (otimes A B) C (otimes B A) C (braid A B) (id C)) (otimes B (otimes A C) B (otimes C A) (id B) (braid A C)))))))
(assert (forall ((A Ob) (B Ob) (C Ob))
  (! (= (braid (otimes A B) C)
        (compose 
            (otimes (otimes A B) C)
            (otimes A (otimes C B))
            (otimes C (otimes A B))
            (otimes A (otimes B C) A (otimes C B) (id A) (braid B C)) (otimes (otimes A C) B (otimes C A) B (braid A C) (id B))))
     :pattern ((braid (otimes A B) C))
     :pattern ((compose 
            (otimes (otimes A B) C)
            (otimes A (otimes C B))
            (otimes C (otimes A B))
            (otimes A (otimes B C) A (otimes C B) (id A) (braid B C)) (otimes (otimes A C) B (otimes C A) B (braid A C) (id B)))))))
(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (f Hom) (g Hom))
  (! 
         (= (compose (otimes A C) (otimes B D) (otimes D B) (otimes A C B D f g) (braid B D))
            (compose (otimes A C) (otimes C A) (otimes D B) (braid A C) (otimes C A D B g f)))
     :pattern ((compose (otimes A C) (otimes B D) (otimes D B) (otimes A C B D f g) (braid B D)))
     :pattern ((compose (otimes A C) (otimes C A) (otimes D B) (braid A C) (otimes C A D B g f))))))
(assert (forall ((A Ob))
  (! (= (compose A (otimes A A) (otimes (otimes A A) A) (mcopy A) (otimes A A (otimes A A) A (mcopy A) (id A)))
        (compose A (otimes A A) (otimes A (otimes A A)) (mcopy A) (otimes A A A (otimes A A) (id A) (mcopy A))))
     :pattern ((compose A (otimes A A) (otimes (otimes A A) A) (mcopy A) (otimes A A (otimes A A) A (mcopy A) (id A))))
     :pattern ((compose A (otimes A A) (otimes A (otimes A A)) (mcopy A) (otimes A A A (otimes A A) (id A) (mcopy A)))))))
(assert (forall ((A Ob))
  (! (= (compose A (otimes A A) A (mcopy A) (otimes A A munit A (delete A) (id A))) (id A))
     :pattern ((compose A (otimes A A) A (mcopy A) (otimes A A munit A (delete A) (id A))))
 ;   :pattern ((id A))
     )))
(assert (forall ((A Ob))
  (! (= (compose A (otimes A A) A (mcopy A) (otimes A A A munit (id A) (delete A))) (id A))
     :pattern ((compose A (otimes A A) A (mcopy A) (otimes A A A munit (id A) (delete A))))
    ; :pattern ((id A))
     )))
(assert (forall ((A Ob))
  (! (= (compose A (otimes A A) (otimes A A) (mcopy A) (braid A A)) (mcopy A))
     :pattern ((compose A (otimes A A) (otimes A A) (mcopy A) (braid A A)))
   ;  :pattern ((mcopy A)))
    )))
(assert (forall ((A Ob) (B Ob))
  (! (let ((a!1 (compose (otimes A B)
                         (otimes (otimes A A) (otimes B B))
                         (otimes (otimes A B) (otimes A B))
                         (otimes A B (otimes A A) (otimes B B) (mcopy A) (mcopy B))
                         (otimes (otimes A (otimes A B)) B (otimes A (otimes B A)) B
                                (otimes A (otimes A B) A (otimes B A)
                                        (id A) (braid A B))
                                (id B)))))
       (= (mcopy (otimes A B)) a!1))
    ; :pattern ((mcopy (otimes A B)))
     :pattern ((compose (otimes A B)
                         (otimes (otimes A A) (otimes B B))
                         (otimes (otimes A B) (otimes A B))
                         (otimes A B (otimes A A) (otimes B B) (mcopy A) (mcopy B))
                         (otimes (otimes A (otimes A B)) B (otimes A (otimes B A)) B
                                (otimes A (otimes A B) A (otimes B A)
                                        (id A) (braid A B))
                                (id B)))))))
(assert (forall ((A Ob) (B Ob))
  (! (= (delete (otimes A B)) (otimes A B munit munit (delete A) (delete B)))
     :pattern ((delete (otimes A B)))
     :pattern ((otimes A B munit munit (delete A) (delete B))))))
(assert (= (mcopy munit) (id munit)))
(assert (= (delete munit) (id munit)))
(assert (forall ((A Ob) (B Ob) (C Ob) (f Hom) (g Hom))
  (! 
         (= (pair A B C f g) (compose C (otimes C C) (otimes B C) (mcopy C) (otimes A A B C f g)))
     :pattern ((pair A B C f g))
     :pattern ((compose C (otimes C C) (otimes B C) (mcopy C) (otimes A A B C f g)) ))))
(assert (forall ((A Ob) (B Ob))
  (! (= (proj1 A B) (otimes A B A munit (id A) (delete B)))
     :pattern ((proj1 A B))
     :pattern ((otimes A B A munit (id A) (delete B))))))
(assert (forall ((A Ob) (B Ob))
  (! (= (proj2 A B) (otimes A B munit B (delete A) (id B)))
     :pattern ((proj2 A B))
     :pattern ((otimes A B munit B (delete A) (id B))))))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (! 
         (= (compose A B (otimes B B) f (mcopy B)) (compose A (otimes A A) (otimes B B) (mcopy A) (otimes A A B B f f)))
     :pattern ((compose A B (otimes B B) f (mcopy B)) )
     :pattern ((compose A (otimes A A) (otimes B B) (mcopy A) (otimes A A B B f f)) ))))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (= (compose A B munit f (delete B)) (delete A))))
;(assert (= (typo (pair (proj1 A B) (proj2 A B))) (Hom (otimes A B) (otimes A B))))
;(assert (= (typo (proj1 A B)) (Hom (otimes A B) A)))
;(assert (= (typo A) Ob))
;(assert (= (typo B) Ob))
;(assert (= (typo (proj2 A B)) (Hom (otimes A B) B)))
;(assert (= (typo A) Ob))
;(assert (= (typo B) Ob))
;(assert (= (typo (otimes (id A) (id B))) (Hom (otimes A B) (otimes A B))))
;(assert (= (typo (id A)) (Hom A A)))
;(assert (= (typo A) Ob))
;(assert (= (typo (id B)) (Hom B B)))
;(assert (= (typo B) Ob))
 ;(assert (not (= (pair (otimes A B) A B (proj1 A B) (proj2 A B)) (otimes A B A B (id A) (id B)))))
 ;(assert (not (=  (compose A A A (id A) (id A)) (id A)  )))
    (assert (not (= 
         (compose (otimes A B) (otimes (otimes A A) (otimes B B)) (otimes A B)
         (otimes A B (otimes A A) (otimes B B) (mcopy A) (mcopy B)) 
              (compose (otimes A (otimes (otimes A B) B )) (otimes A (otimes (otimes B A) B)) (otimes A B)
                   (otimes A (otimes (otimes A B) B) A (otimes (otimes B A) B) 
                        (id A) (otimes (otimes A B) B (otimes B A) B
                                    (braid A B) (id B))) 
                   (otimes A (otimes B (otimes A B)) A B
                      (id A) (otimes B (otimes A B) munit B
                                  (delete B) 
                                  (otimes A B munit B 
                                         (delete A) (id B))))))

         (compose (otimes A B) (otimes (otimes A A) (otimes B B)) (otimes A B)
             (otimes A B (otimes A A) (otimes B B) (mcopy A) (mcopy B)) 
             (otimes A (otimes (otimes A B) B) A B
                 (compose A A A (id A) (id A)) 
                 (compose (otimes (otimes A B) B) (otimes (otimes B A) B) B
                       (otimes (otimes A B) B (otimes B A) B (braid A B) (id B))
                       (otimes B (otimes A B) munit B
                               (delete B) 
                               (otimes A B munit B 
                                   (delete A) (id B))))))
     )))

(check-sat)